var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/google-fonts.ts
var GoogleFontsBase = "https://fonts.googleapis.com/css2";
function injectFonts({
  families,
  text,
  preconnect = true,
  display = "swap"
}) {
  const specs = [];
  const deferedSpecs = [];
  const tags = [];
  if (!Array.isArray(families)) {
    console.warn("Google font families is required");
    return tags;
  }
  if (families.length >= 0) {
    for (const family of families) {
      if (typeof family === "string") {
        deferedSpecs.push(family);
        continue;
      }
      if (!family)
        continue;
      const {
        name,
        styles,
        defer = true
      } = family;
      if (!name) {
        console.warn("A google font family name is missing");
        continue;
      }
      let spec = name;
      if (typeof styles === "string")
        spec += `:${styles}`;
      if (defer)
        deferedSpecs.push(spec);
      else
        specs.push(spec);
    }
  }
  if (preconnect && specs.length + deferedSpecs.length > 0) {
    tags.push({
      tag: "link",
      attrs: {
        rel: "preconnect",
        href: "https://fonts.gstatic.com/",
        crossorigin: true
      }
    });
  }
  if (deferedSpecs.length > 0) {
    let href = `${GoogleFontsBase}?family=${deferedSpecs.join("&family=")}`;
    if (typeof display === "string" && display !== "auto")
      href += `&display=${display}`;
    if (typeof text === "string" && text.length > 0)
      href += `&text=${text}`;
    tags.push({
      tag: "link",
      attrs: {
        rel: "preload",
        as: "style",
        onload: "this.rel='stylesheet'",
        href
      }
    });
  }
  if (specs.length > 0) {
    let href = `${GoogleFontsBase}?family=${specs.join("&family=")}`;
    if (typeof display === "string" && display !== "auto")
      href += `&display=${display}`;
    if (typeof text === "string" && text.length > 0)
      href += `&text=${text}`;
    tags.push({
      tag: "link",
      attrs: {
        rel: "stylesheet",
        href
      }
    });
  }
  return tags;
}
var google_fonts_default = injectFonts;

// src/typekit.ts
var TypekitFontBase = "https://use.typekit.net/";
function injectFonts2({
  id,
  defer = true
}) {
  const tags = [];
  if (typeof id !== "string") {
    console.warn("A Typekit id is required");
    return tags;
  }
  if (defer) {
    tags.push({
      tag: "link",
      attrs: {
        rel: "preload",
        as: "style",
        onload: "this.rel='stylesheet'",
        href: `${TypekitFontBase}${id}.css`
      }
    });
  } else {
    tags.push({
      tag: "link",
      attrs: {
        rel: "stylesheet",
        href: `${TypekitFontBase}${id}.css`
      }
    });
  }
  return tags;
}
var typekit_default = injectFonts2;

// src/custom.ts
import { sync as glob } from "fast-glob";
var resolveWeight = (weightOrSrc) => {
  if (typeof weightOrSrc === "number")
    return weightOrSrc;
  if (!weightOrSrc)
    return 400;
  weightOrSrc = weightOrSrc.toLowerCase();
  if (weightOrSrc.includes("thin"))
    return 100;
  if (weightOrSrc.includes("extralight"))
    return 200;
  if (weightOrSrc.includes("ultralight"))
    return 200;
  if (weightOrSrc.includes("light"))
    return 300;
  if (weightOrSrc.includes("normal"))
    return 400;
  if (weightOrSrc.includes("medium"))
    return 500;
  if (weightOrSrc.includes("semibold"))
    return 600;
  if (weightOrSrc.includes("demibold"))
    return 600;
  if (weightOrSrc.includes("bold"))
    return 700;
  if (weightOrSrc.includes("extrabold"))
    return 800;
  if (weightOrSrc.includes("ultrabold"))
    return 800;
  if (weightOrSrc.includes("black"))
    return 900;
  if (weightOrSrc.includes("heavy"))
    return 900;
  return 400;
};
var resolveStyle = (styleOrSrc) => {
  if (!styleOrSrc)
    return "normal";
  styleOrSrc = styleOrSrc.toLowerCase();
  if (styleOrSrc.includes("normal"))
    return "normal";
  if (styleOrSrc.includes("italic"))
    return "italic";
  if (styleOrSrc.includes("oblique"))
    return "oblique";
  return "normal";
};
var createFontFaceCSS = ({ name, src, local, weight, style, display }) => {
  const srcs = (Array.isArray(src) ? src : [src]).filter(Boolean).map((url) => {
    let format = url.split(".").pop();
    if (format === "ttf")
      format = "truetype";
    return `url('${url}') format('${format}')`;
  }).join(",\n		");
  const locals = (Array.isArray(local) ? local : [local]).filter(Boolean).map((x) => `local('${x}')`).join(", ");
  return `@font-face {
  font-family: '${name}';
  src: ${[srcs, locals].filter(Boolean).join(",")};
  font-weight: ${weight};
  font-style: ${style};
  font-display: ${display};
}`;
};
var createFontFaceLink = (href) => {
  return {
    tag: "link",
    attrs: {
      rel: "preload",
      as: "font",
      type: `font/${href.split(".").pop()}`,
      href,
      crossorigin: true
    }
  };
};
var custom_default = (options, config2) => {
  const tags = [];
  const css = [];
  let {
    families = [],
    display = "auto",
    preload = true
  } = options;
  if (!Array.isArray(families)) {
    families = Object.entries(families).map(([name, family]) => Array.isArray(family) || typeof family === "string" ? { name, src: family } : __spreadValues({ name }, family));
  }
  for (const { name, src, local } of families) {
    const facesGrouped = {};
    (Array.isArray(src) ? src : [src]).flatMap((x) => glob(x, { absolute: true, cwd: config2.root, onlyFiles: true })).filter(Boolean).forEach((src2) => {
      var _a, _b;
      const srcNoExt = (_a = src2.match(/(.*)\.(\w|\d)+$/)) == null ? void 0 : _a[1].toLowerCase();
      if (srcNoExt)
        facesGrouped[srcNoExt] = ((_b = facesGrouped[srcNoExt]) != null ? _b : []).concat(src2);
    });
    const faces = Object.entries(facesGrouped).map(([srcNoExt, src2]) => ({
      name,
      src: src2,
      weight: resolveWeight(srcNoExt),
      style: resolveStyle(srcNoExt),
      display,
      local
    }));
    const hrefs = faces.flatMap((face) => face.src).map((src2) => src2.replace(config2.root, "."));
    if (preload)
      tags.push(...hrefs.map(createFontFaceLink));
    for (const face of faces)
      css.push(createFontFaceCSS(face));
  }
  return {
    tags,
    css: css.join("\n\n")
  };
};

// src/index.ts
var config;
var MODULE_ID = "virtual:fonts.css";
var MODULE_ID_RESOLVED = "/@vite-plugin-fonts/fonts.css";
function VitePluginFonts(options = {}) {
  return {
    name: "vite-plugin-fonts",
    enforce: "pre",
    configResolved(_config) {
      config = _config;
    },
    transformIndexHtml: {
      enforce: "pre",
      transform: () => {
        const tags = [];
        if (options.typekit)
          tags.push(...typekit_default(options.typekit));
        if (options.google)
          tags.push(...google_fonts_default(options.google));
        if (options.custom)
          tags.push(...custom_default(options.custom, config).tags);
        return tags;
      }
    },
    resolveId(id) {
      if (id === MODULE_ID)
        return MODULE_ID_RESOLVED;
    },
    load(id) {
      if (id === MODULE_ID_RESOLVED)
        return options.custom ? custom_default(options.custom, config).css : "";
    }
  };
}
var src_default = VitePluginFonts;
export {
  VitePluginFonts,
  src_default as default
};
